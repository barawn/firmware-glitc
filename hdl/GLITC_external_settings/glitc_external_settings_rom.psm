CONSTANT	master_control,	00
CONSTANT	dac_pending,	01
CONSTANT	atten_pending,	02
CONSTANT	err_out,	03
CONSTANT	dac_base,	10
CONSTANT	att_base,	20
CONSTANT	bias_enable,	30
CONSTANT	att_control,	31

CONSTANT	att_A,		20
CONSTANT	att_B,		21
CONSTANT	att_C,		22
CONSTANT	att_D,		23
CONSTANT	att_E,		24
CONSTANT	att_F,		25

; Attenuator addresses:
; 000
; 001
; 100
; 101
; 110
; 111
CONSTANT	att_A_address,	00
CONSTANT	att_B_address,	01
CONSTANT	att_C_address,	04
CONSTANT	att_D_address,	05
CONSTANT	att_E_address,	06
CONSTANT	att_F_address,	07

CONSTANT	dac_A_L,	10
CONSTANT	dac_A_H,	11
CONSTANT	dac_B_L,	12
CONSTANT	dac_B_H,	13
CONSTANT	dac_C_L,	14
CONSTANT	dac_C_H,	15
CONSTANT	dac_SPARE0_L,	16
CONSTANT	dac_SPARE0_H,	17
CONSTANT	dac_D_L,	18
CONSTANT	dac_D_H,	19
CONSTANT	dac_E_L,	1A
CONSTANT	dac_E_H,	1B
CONSTANT	dac_F_L,	1C
CONSTANT	dac_F_H,	1D
CONSTANT	dac_SPARE1_L,	1E
CONSTANT	dac_SPARE1_H,	1F

CONSTANT	mc_upd_pending, 01
CONSTANT	mc_err_pending, 02
CONSTANT	mc_initialized, 04
CONSTANT	mc_pause,	08
CONSTANT	mc_reset,	80
CONSTANT	mc_tiscv2,	10

CONSTANT	prerlo,		80
CONSTANT	prerhi,		81
CONSTANT	ctr,		82
CONSTANT	txr,		83
CONSTANT	rxr,		83
CONSTANT	cr,		84
CONSTANT	sr,		84

CONSTANT	cr_wr_and_sta,	90
CONSTANT	cr_wr,		10
CONSTANT	cr_rd,		20
CONSTANT	cr_sto,		40
CONSTANT	cr_rd_and_nack,	28
CONSTANT	sr_rxack,	80
CONSTANT	sr_al,		20
CONSTANT	sr_rxack_or_al,	A0
CONSTANT	sr_busy,	40
CONSTANT	sr_tip,		02
CONSTANT	sr_busy_or_tip,	42

CONSTANT	tca6416a_0,	40
CONSTANT	tca6416a_1,	42
CONSTANT	mcp4728_0,	C2
CONSTANT	mcp4728_1,	C0
CONSTANT	mcp4728_dflt,	C0

; Scratchpad RAM locations.
CONSTANT	i2c_buffer,	 00
CONSTANT	i2c_buffer_1,	 01
CONSTANT	i2c_buffer_2,	 02
CONSTANT	i2c_buffer_3,	 03
CONSTANT	err_buffer,	 10
CONSTANT	i2c_initialized, 18

; Errors.
CONSTANT	err_tca6416a_0_NACKed, 01
CONSTANT	err_tca6416a_1_NACKed, 02
CONSTANT	err_mcp4728_0_NACKed, 03
CONSTANT	err_mcp4728_1_NACKed, 04
CONSTANT	err_spurious_upd_pending, 05

NAMEREG		sF, err_wr_ptr
NAMEREG		sE, err_rd_ptr

reset:
	load	err_rd_ptr,	00
	load	err_wr_ptr,	00
	load	s0, mc_reset
	output	s0, master_control
reset_initialize:
	load	s0, 00
	store	s0, i2c_initialized
	call	i2c_initialize
main_loop:
	call	read_error
	input	s0, master_control
	fetch	s1, i2c_initialized
	compare	s1, 01
	jump	NZ, main_loop_jp1
	test	s0, mc_initialized
	jump	Z, reset_initialize
main_loop_jp1:
	test	s0, mc_pause
	jump	NZ, main_loop
	test	s0, mc_upd_pending
	jump	Z, main_loop
	input	s0, dac_pending
	test	s0, 0F
	jump	NZ, update_mcp4728_0
	test	s0, F0
	jump	NZ, update_mcp4728_1
	input	s0, atten_pending
	test	s0, 07
	jump	NZ, update_tca6416a_0
	test	s0, 38
	jump	NZ, update_tca6416a_1
	load	s0, err_spurious_upd_pending
	call	write_error
	jump	main_loop

update_mcp4728_0:
	load	s3, s0
	load	s0, mcp4728_0
	load	s8, 00
	load	s9, i2c_buffer
	; Find first DAC.
	test    s3, 01
	jump	Z,  update_mcp4728_0_dacB
	; Command byte
	load	sA, 40
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte.
	input	sA, dac_A_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_A_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 01
	output	sA, dac_pending
update_mcp4728_0_dacB:
	test	s3, 02
	jump	Z,  update_mcp4728_0_dacC
	; Command byte
	load	sA, 42
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_B_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_B_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 02
	output	sA, dac_pending
update_mcp4728_0_dacC:
	test	s3, 04
	jump	Z,  update_mcp4728_0_dacD
	; Command byte
	load	sA, 44
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_C_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_C_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 04
	output	sA, dac_pending
update_mcp4728_0_dacD:
	test	s3, 08
	jump	Z,  update_mcp4728_0_execute
	; Command byte
	load	sA, 46
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_SPARE0_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_SPARE0_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 08
	output	sA, dac_pending
update_mcp4728_0_execute:
	load	s1, s8
	load	s2, 00
	call	i2c_execute
	jump	main_loop		

update_mcp4728_1:
	load	s3, s0
	load	s0, mcp4728_1
	load	s8, 00
	load	s9, i2c_buffer
	; Find first DAC.
	test    s3, 10
	jump	Z,  update_mcp4728_1_dacB
	; Command byte
	load	sA, 40
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte.
	input	sA, dac_D_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_D_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 10
	output	sA, dac_pending
update_mcp4728_1_dacB:
	test	s3, 20
	jump	Z,  update_mcp4728_1_dacC
	; Command byte
	load	sA, 42
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_E_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_E_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 20
	output	sA, dac_pending
update_mcp4728_1_dacC:
	test	s3, 40
	jump	Z,  update_mcp4728_1_dacD
	; Command byte
	load	sA, 44
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_F_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_F_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 40
	output	sA, dac_pending
update_mcp4728_1_dacD:
	test	s3, 80
	jump	Z,  update_mcp4728_1_execute
	; Command byte
	load	sA, 46
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; High byte
	input	sA, dac_SPARE1_H
	and	sA, 0F
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	; Low byte
	input	sA, dac_SPARE1_L
	store	sA, (s9)
	add	s9, 01
	add	s8, 01
	load	sA, 80
	output	sA, dac_pending
update_mcp4728_1_execute:
	load	s1, s8
	load	s2, 00
	call	i2c_execute
	jump	main_loop		

update_tca6416a_0:
	load	s3, s0
	; Is this a TISCv1, or TISCv2?
	input	s0, master_control
	test	s0, mc_tiscv2
	jump	NZ, update_rfsa3713_ABC
	; For the TCA6416As, we ned to write all of them at once.
	; The firmware has the FIRST tca6416a inputs wired backwards to the PicoBlaze, so
	; we don't need to realign them here.
	load	s8, 02
	store	s8, i2c_buffer
	; Fetch first attenuator.
	input	s8, att_A
	and	s8, 1F
	; Fetch second attenuator.
	input 	s9, att_B
	and	s9, 1F
	; Shift first 3 bits into sA's top 3 bits.
	load	sA, 00
	sr0	s9
	sra	sA
	sr0	s9
	sra	sA
	sr0	s9
	sra	sA
	; Combine top 3 bits with first attenuator.
	add	s8, sA
	; Fetch third attenuator.
	input	sA, att_C
	; Shift it up two.
	sl0	sA
	sl0	sA
	; Combine with top 2 bits of second attenuator.
	add	s9, sA
	; And add LDAC to keep it high.
	or    	s9, 80
	store	s8, i2c_buffer_1
	store	s9, i2c_buffer_2
	load	s1, 03
	load	s2, 00
	; Clear any pending bits, since we just read them.
	output	s0, atten_pending
	load  	s0, tca6416a_0
	call	i2c_execute
	jump	main_loop
	
update_tca6416a_1:
	input	s0, master_control
	test	s0, mc_tiscv2
	jump	NZ, update_rfsa3713_DEF
	; For the TCA6416As, we ned to write all of them at once.
	; The firmware has the SECOND tca6416a inputs wired direct to the PicoBlaze, so
	; we don't need to realign them here.
	load	s8, 02
	store	s8, i2c_buffer
	; Fetch first attenuator.
	input	s8, att_D
	and	s8, 1F
	; Fetch second attenuator.
	input 	s9, att_E
	and	s9, 1F
	; Shift first 3 bits into sA's top 3 bits.
	load	sA, 00
	sr0	s9
	sra	sA
	sr0	s9
	sra	sA
	sr0	s9
	sra	sA
	; Combine top 3 bits with first attenuator.
	add	s8, sA
	; Fetch third attenuator.
	input	sA, att_F
	; Shift it up two.
	sl0	sA
	sl0	sA
	; Combine with top 2 bits of second attenuator.
	add	s9, sA
	; And add LDAC to keep it high.
	or    	s9, 80
	store	s8, i2c_buffer_1
	store	s9, i2c_buffer_2
	load	s1, 03
	load	s2, 00
	; Clear any pending bits, since we just read them.
	output	s0, atten_pending
	load  	s0, tca6416a_1
	call	i2c_execute
	jump	main_loop

update_rfsa3713_ABC:
	; Figure out which attenuators need to be updated,
	; and do it here.
update_rfsa3713_A:
	test    s3, 01
	jump	Z, update_rfsa3713_B
	input	s1, att_A
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_A_address
	call	update_rfsa3713
update_rfsa3713_B:
	test	s3, 02
	jump	Z, update_rfsa3713_C
	input	s1, att_B
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_B_address
	call	update_rfsa3713
update_rfsa3713_C:
	test	s3, 04
	jump	Z, update_rfsa3713_ABC_finish
	input	s1, att_B
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_C_address
	call	update_rfsa3713
update_rfsa3713_ABC_finish:
	output	s3, atten_pending	
	jump	main_loop

update_rfsa3713_DEF:
update_rfsa3713_D:
	test    s3, 08
	jump	Z, update_rfsa3713_E
	input	s1, att_D
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_D_address
	call	update_rfsa3713
update_rfsa3713_E:
	test	s3, 10
	jump	Z, update_rfsa3713_F
	input	s1, att_E
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_E_address
	call	update_rfsa3713
update_rfsa3713_F:
	test	s3, 20
	jump	Z, update_rfsa3713_DEF_finish
	input	s1, att_F
	; Since we're a TISCv2, the attenuator settings come in directly.
	load	s0, att_F_address
	call	update_rfsa3713
update_rfsa3713_DEF_finish:
	output	s3, atten_pending
	jump	main_loop


	; s0 contains the attenuator address code to update.
	; s1 contains the value to update it to.
	; First, we clock in the attenuator address code. LSB first.
update_rfsa3713:
	load	s8, 08
update_rfsa3713_jp1:
	sr0	s1					; Shift s1 right.
	load	s9, 00					; Clear S9, prepping for carry add
	addcy	s9, 00					; Add carry from the s1 shift. (s9 is now 0 or 1)
	output	s9, att_control				; Output it.
	or	s9, 02					; Raise clk.
	output	s9, att_control				; Output it.
	xor	s9, 02					; Clear clock.
	output	s9, att_control				; Output it.
	sub	s8, 01					; Clocked out 8 bits yet?
	jump	NZ, update_rfsa3713_jp1
	load	s8, 08					; Set up 8 bit shift.
update_rfsa3713_jp2:
	sr0	s0					; Shift s0 right.
	load	s9, 00					; Clear s9, prepping for carry add.
	addcy	s9, 00					; Add carry from s0 shift. (s9 is now 0 or 1)
	output	s9, att_control				; Output it.
	or	s9, 02					; Raise clk.
	output	s9, att_control				; Output it.
	xor	s9, 02					; Lower clk.
	output	s9, att_control				; Output it.
	sub	s8, 01					; Clocked out 8 bits yet?
	jump	NZ, update_rfsa3713_jp2
	load	s9, 04					; Raise LE.
	output	s9, att_control				; Output it.
	load	s9, 00					; Lower LE.
	output	s9, att_control				; Output it.
	return	    					; Done.
	
read_error:
	input	s0, master_control		; fetch master control
	test	s0, mc_err_pending		; is the error pending set?
	return	NZ				; if so, not ready for new err
	compare	err_wr_ptr, err_rd_ptr		; is an error in the buffer?
	return	Z	    			; if not, return
	fetch	s0, (err_rd_ptr)		; yes - so fetch it
	add	err_rd_ptr, 01			; increment ptr
	and	err_rd_ptr, F7			; mask off bit 3 (7 entries)
	output	s0, err_out 			; output it
	load	s0, mc_err_pending
	output	s0, master_control		; and set error_pending
	return

i2c_initialize:
	load	s1, 00
	input	s0, sr
	test	s0, sr_tip
	jump	NZ, i2c_initialize
	load	s0, 00
	output	s0, ctr
	load	s0, 0F
	output	s0, prerlo
	load	s0, 00
	output	s0, prerhi
	load	s0, 80
	output	s0, ctr

i2c_initialize_jp0:
	load	s0, tca6416a_0
	; NZ indicates error
	call	i2c_check_if_present
	jump	Z, i2c_initialize_jp1
	; No TCA6416, so we're a TISCv2
	load 	s0, mc_tiscv2
	output	s0, master_control
	jump	i2c_initialize_jp4
i2c_initialize_jp1:
	load	s0, tca6416a_1
	call	i2c_check_if_present
	jump	Z, i2c_initialize_jp2
	load	s0, err_tca6416a_1_NACKed
	call	write_error
	load	s1, 01
	; Both TCA6416s are present. Set them up.
i2c_initialize_jp2:
	load    s0, tca6416a_0
	call	tca6416a_initialize
	jump	Z, i2c_initialize_jp3
	load	s0, err_tca6416a_0_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp3:
	load	s0, tca6416a_1
	call	tca6416a_initialize
	jump	Z, i2c_initialize_jp4
	load	s0, err_tca6416a_1_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp4:
	; MCP4728
	; TISCv2, yes or no?
	input	s4, master_control
	; Check if the first MCP4728 is present.
	load	s0, mcp4728_0
	call	i2c_check_if_present
	; No error?
	jump	Z, i2c_initialize_jp6
	test	s4, mc_tiscv2
	jump	NZ, i2c_initialize_jp5
	load	s0, err_mcp4728_0_NACKed
	call	write_error
	load	s1, 01
	jump	i2c_initialize_jp6
i2c_initialize_jp5:
	call	program_mcp4728
	; So now probe the two DACs.
i2c_initialize_jp6:
	load	s0, mcp4728_0
	call	i2c_check_if_present
	jump	Z, i2c_initialize_jp7
	load	s0, err_mcp4728_0_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp7:
	load	s0, mcp4728_1
	call	i2c_check_if_present
	jump	Z, i2c_initialize_jp8
	load	s0, err_mcp4728_1_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp8:
	load	s0, mcp4728_0
	call	mcp4728_initialize
	jump	Z, i2c_initialize_jp9
	load	s0, err_mcp4728_0_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp9:
	load	s0, mcp4728_1
	call	mcp4728_initialize
	jump	Z, i2c_initialize_jp10
	load	s0, err_mcp4728_1_NACKed
	call	write_error
	load	s1, 01
i2c_initialize_jp10:
	test	s1, 01
	return	Z
	store	s1, i2c_initialized
	load	s0, mc_initialized
	output	s0, master_control
	return

	; s0: address of tca6416a to initialize
	; Return NZ with error.
tca6416a_initialize:
	load	s1, 03
	load	s2, 00
	load	s8, 02
	store	s8, i2c_buffer
	load	s8, FF
	store	s8, i2c_buffer_1
	store	s8, i2c_buffer_2
	call 	i2c_execute
	; if NZ, error
	return  NZ
	load	s1, 03
	load	s8, 06
	store	s8, i2c_buffer
	store	s2, i2c_buffer_1
	store	s2, i2c_buffer_2
	call	i2c_execute
	return

	; s0: address of mcp4728 to initialize
	; Initializes MCP4728 by setting all gains to 1.
	; 
	; Return NZ with error.
mcp4728_initialize:
	load	s1, 01
	load	s2, 00
	load	s8, C0
	store	s8, i2c_buffer
	call	i2c_execute
	return

program_mcp4728:
	call i2c_wait_until_done
	
	load	s8, C0
	output	s8, att_control
	load	s8, mcp4728_dflt
	output	s8, txr
	load	s8, cr_wr_and_sta
	output	s8, cr
	call 	i2c_wait_until_done
	test 	s8, sr_rxack
	jump	NZ, program_mcp4728_stop_return
	; Command bits = 011, current address = 000, and 01 in bottom bits.
	load	s8, 61
	output	s8, txr
	load	s8, cr_wr
	output	s8, cr
	; set do_ldac.
	load	s8, 10
	output	s8, att_control
	call	i2c_wait_until_done
	test	s8, sr_rxack
	jump	NZ, program_mcp4728_stop_return
	; Command bits = 011, new address = 001, and 10 in bottom bits
	load	s8, 66
	output	s8, txr
	load	s8, cr_wr
	output	s8, cr
	call	i2c_wait_until_done
	test	s8, sr_rxack
	jump	NZ, program_mcp4728_stop_return
	; Command bits = 011, new address = 001, and 11 in bottom bits.
	load	s8, 67
	output	s8, txr
	load	s8, cr_wr
	output	s8, cr
	call	i2c_wait_until_done
	test	s8, sr_rxack
	jump	NZ, program_mcp4728_stop_return
	load	s8, cr_sto
	output	s8, cr
	call	i2c_wait_until_free
	; clear ldac
	load	s8, C0
	output	s8, att_control
	return	
program_mcp4728_stop_return:
	load	s8, cr_sto
	output	s8, cr
	call	i2c_wait_until_free
	; Need to clear Z.
	sl1    s8
	load   s8, C0
	output s8, att_control
	return
	

	; s0 = i2c_address
	; s1 = i2c_txlen
	; s2 = i2c_rxlen
	; return NZ with error
i2c_execute:
	call i2c_wait_until_done
	compare	s1, 00					; check TX length
	jump	Z, i2c_execute_read			; if 0, just read
	output	s0, txr					; output address
	load	s8, cr_wr_and_sta			; output STA+WR
	output	s8, cr
	call i2c_wait_until_done
	test s8, sr_rxack				; Did we get a NACK?
	jump NZ, i2c_execute_stop_return_err		; if so, set error
	load   s9, i2c_buffer				; Now send data.
i2c_execute_write_loop:
	fetch  s8, (s9)
	output s8, txr
	load   s8, cr_wr
	output s8, cr
	call   i2c_wait_until_done
	test   s8, sr_rxack				; Did we get a NACK?
	jump   NZ, i2c_execute_stop_return_err		; if so, set error.
	add    s9, 01
	sub    s1, 01
	jump   NZ, i2c_execute_write_loop
	load   s8, cr_sto
	output s8, cr
	call   i2c_wait_until_free
i2c_execute_read:
	compare	s2, 00
	jump	Z, i2c_execute_finish
	load	s8, s0
	add	s8, 01
	output	s8, txr
	load	s8, cr_wr_and_sta
	output	s8, cr
	call	i2c_wait_until_done			
	test	s8, sr_rxack				; Did we get a NACK?
	jump	NZ, i2c_execute_stop_return_err		; If so, set error.
	load	s9, i2c_buffer
i2c_execute_read_loop:
	load	s8, cr_rd
	sub	s2, 01
	jump	NZ, i2c_execute_read_jp1
	load	s8, cr_rd_and_nack
i2c_execute_read_jp1:
	output	s8, cr
	call	i2c_wait_until_done
	input	s8, rxr
	store	s8, (s9)
	add	s9, 01
	compare	s2, 00
	jump	NZ, i2c_execute_read_loop
	load	s8, cr_sto
	output	s8, cr
	call 	i2c_wait_until_free
i2c_execute_finish:
	; Z is already set (i2c_wait_until_free, or previous jump).
	return
i2c_execute_stop_return_err:
	load	s8, cr_sto
	output	s8, cr
	call	i2c_wait_until_free
	; Need to clear Z.
	sl1    s8
	return

	; Write an error into the buffer.
	; s0: Error to store in buffer.
write_error:
	load	s8, err_wr_ptr
	add	s8, 01
	and	s8, 0F
	compare	s8, err_rd_ptr
	; Do nothing if the error buffer is full.
	return	Z
	store	s0, (err_wr_ptr)
	load	err_wr_ptr, s8
	return

	; Check for existence of an I2C address.
	; s0: address to check
	; return NZ with error
i2c_check_if_present:
	output	s0, txr
	load	s0, cr_wr_and_sta
	output	s0, cr
	call	i2c_wait_until_done
	load	s0, cr_sto
	output	s0, cr
	call	i2c_wait_until_free
	test	s8, sr_rxack
	return

	; Wait until TIP is clear in status register.
i2c_wait_until_done:
	input	s8, sr
	test	s8, sr_tip
	return	Z
	jump	i2c_wait_until_done

	; Wait until BUSY is clear in status register.
i2c_wait_until_free:
	input	s8, sr
	test	s8, sr_busy
	return	Z
	jump	i2c_wait_until_free
	